$date
	Mon Mar 10 00:02:41 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module pipelined_processor $end
$var wire 16 ! instruction_F [15:0] $end
$var wire 2 " write_mode_W [1:0] $end
$var wire 2 # write_mode_E [1:0] $end
$var wire 2 $ write_mode_D [1:0] $end
$var wire 1 % stall_F $end
$var wire 1 & stall_D $end
$var wire 3 ' rs2_D [2:0] $end
$var wire 3 ( rs1_D [2:0] $end
$var wire 16 ) reg_write_data_W [15:0] $end
$var wire 1 * reg_write_W $end
$var wire 1 + reg_write_E $end
$var wire 1 , reg_write_D $end
$var wire 16 - reg_data_2_E [15:0] $end
$var wire 16 . reg_data_2_D [15:0] $end
$var wire 16 / reg_data_1_E [15:0] $end
$var wire 16 0 reg_data_1_D [15:0] $end
$var wire 3 1 rd_W [2:0] $end
$var wire 3 2 rd_E [2:0] $end
$var wire 3 3 rd_D [2:0] $end
$var wire 11 4 pc_F [10:0] $end
$var wire 11 5 pc_E [10:0] $end
$var wire 11 6 pc_D [10:0] $end
$var wire 5 7 opcode_W [4:0] $end
$var wire 5 8 opcode_E [4:0] $end
$var wire 5 9 opcode_D [4:0] $end
$var wire 16 : next_flags_E [15:0] $end
$var wire 1 ; mem_write_E $end
$var wire 1 < mem_write_D $end
$var wire 1 = mem_to_reg_W $end
$var wire 1 > mem_to_reg_D $end
$var wire 16 ? mem_read_data_E [15:0] $end
$var wire 1 @ mem_read_E $end
$var wire 1 A mem_read_D $end
$var wire 16 B mem_data_W [15:0] $end
$var wire 1 C jump_D $end
$var wire 16 D instruction_D [15:0] $end
$var wire 8 E immediate_E [7:0] $end
$var wire 8 F immediate_D [7:0] $end
$var wire 2 G forward_B [1:0] $end
$var wire 2 H forward_A [1:0] $end
$var wire 1 I flush_F $end
$var wire 1 J flush_D $end
$var wire 16 K current_flags_E [15:0] $end
$var wire 1 L branch_D $end
$var wire 4 M bit_pos_E [3:0] $end
$var wire 4 N bit_pos_D [3:0] $end
$var wire 1 O alu_src_E $end
$var wire 1 P alu_src_D $end
$var wire 16 Q alu_result_1_W [15:0] $end
$var wire 16 R alu_result_1_E [15:0] $end
$var wire 16 S alu_result_0_W [15:0] $end
$var wire 16 T alu_result_0_E [15:0] $end
$var wire 16 U alu_operand_2 [15:0] $end
$var wire 16 V alu_operand_1 [15:0] $end
$var wire 1 W alu_op_D $end
$var reg 1 X clk $end
$var reg 1 Y rst $end
$scope module alu_unit $end
$var wire 16 Z operand_1 [15:0] $end
$var wire 16 [ operand_2 [15:0] $end
$var wire 5 \ opcode [4:0] $end
$var wire 16 ] current_flags [15:0] $end
$var wire 4 ^ bit_position [3:0] $end
$var reg 17 _ add_temp [16:0] $end
$var reg 32 ` mul_temp [31:0] $end
$var reg 16 a next_flags [15:0] $end
$var reg 16 b result_0 [15:0] $end
$var reg 16 c result_1 [15:0] $end
$scope function parity $end
$upscope $end
$scope task set_common_flags $end
$var reg 16 d value [15:0] $end
$upscope $end
$upscope $end
$scope module cu $end
$var wire 5 e opcode [4:0] $end
$var reg 1 W alu_op $end
$var reg 1 P alu_src $end
$var reg 1 L branch $end
$var reg 1 C jump $end
$var reg 1 A mem_read $end
$var reg 1 > mem_to_reg $end
$var reg 1 < mem_write $end
$var reg 1 , reg_write $end
$var reg 2 f write_mode [1:0] $end
$upscope $end
$scope module data_memory $end
$var wire 11 g address [10:0] $end
$var wire 1 X clk $end
$var wire 16 h read_data [15:0] $end
$var wire 1 ; write_en $end
$var wire 16 i data_in [15:0] $end
$upscope $end
$scope module de_reg $end
$var wire 1 P alu_src_in $end
$var wire 4 j bit_position_in [3:0] $end
$var wire 1 X clk $end
$var wire 8 k immediate_in [7:0] $end
$var wire 1 A mem_read_in $end
$var wire 1 < mem_write_in $end
$var wire 5 l opcode_in [4:0] $end
$var wire 3 m reg_write_addr_in [2:0] $end
$var wire 1 , reg_write_in $end
$var wire 1 Y reset $end
$var wire 2 n write_mode_in [1:0] $end
$var wire 1 & stall_D $end
$var wire 16 o reg_data_2_in [15:0] $end
$var wire 16 p reg_data_1_in [15:0] $end
$var wire 11 q pc_in [10:0] $end
$var wire 1 J flush_D $end
$var reg 1 O alu_src_out $end
$var reg 4 r bit_position_out [3:0] $end
$var reg 8 s immediate_out [7:0] $end
$var reg 1 @ mem_read_out $end
$var reg 1 ; mem_write_out $end
$var reg 5 t opcode_out [4:0] $end
$var reg 11 u pc_out [10:0] $end
$var reg 16 v reg_data_1_out [15:0] $end
$var reg 16 w reg_data_2_out [15:0] $end
$var reg 3 x reg_write_addr_out [2:0] $end
$var reg 1 + reg_write_out $end
$var reg 2 y write_mode_out [1:0] $end
$upscope $end
$scope module ew_reg $end
$var wire 16 z alu_result_0_in [15:0] $end
$var wire 16 { alu_result_1_in [15:0] $end
$var wire 1 X clk $end
$var wire 16 | mem_data_in [15:0] $end
$var wire 1 @ mem_to_reg_in $end
$var wire 5 } opcode_in [4:0] $end
$var wire 3 ~ reg_write_addr_in [2:0] $end
$var wire 1 + reg_write_in $end
$var wire 1 Y reset $end
$var wire 2 !" write_mode_in [1:0] $end
$var reg 16 "" alu_result_0_out [15:0] $end
$var reg 16 #" alu_result_1_out [15:0] $end
$var reg 16 $" mem_data_out [15:0] $end
$var reg 1 = mem_to_reg_out $end
$var reg 5 %" opcode_out [4:0] $end
$var reg 3 &" reg_write_addr_out [2:0] $end
$var reg 1 * reg_write_out $end
$var reg 2 '" write_mode_out [1:0] $end
$upscope $end
$scope module fd_reg $end
$var wire 1 X clk $end
$var wire 16 (" instruction_in [15:0] $end
$var wire 1 Y reset $end
$var wire 1 % stall_F $end
$var wire 11 )" pc_in [10:0] $end
$var wire 1 I flush_F $end
$var reg 16 *" instruction_out [15:0] $end
$var reg 11 +" pc_out [10:0] $end
$upscope $end
$scope module flag_reg $end
$var wire 1 X clk $end
$var wire 16 ," next_flags [15:0] $end
$var wire 1 Y reset $end
$var reg 16 -" current_flags [15:0] $end
$upscope $end
$scope module hazard_unit $end
$var wire 1 L branch_D $end
$var wire 1 C jump_D $end
$var wire 1 @ mem_read_E $end
$var wire 5 ." opcode_D [4:0] $end
$var wire 5 /" opcode_E [4:0] $end
$var wire 3 0" rd_E [2:0] $end
$var wire 3 1" rd_W [2:0] $end
$var wire 1 + reg_write_E $end
$var wire 1 * reg_write_W $end
$var wire 3 2" rs1_D [2:0] $end
$var wire 3 3" rs2_D [2:0] $end
$var reg 1 J flush_D $end
$var reg 1 I flush_F $end
$var reg 2 4" forward_A [1:0] $end
$var reg 2 5" forward_B [1:0] $end
$var reg 1 & stall_D $end
$var reg 1 % stall_F $end
$upscope $end
$scope module pc_unit $end
$var wire 11 6" branch_addr [10:0] $end
$var wire 1 7" branch_en $end
$var wire 1 X clk $end
$var wire 1 8" inc $end
$var wire 1 Y rst $end
$var reg 11 9" current_addr [10:0] $end
$upscope $end
$scope module reg_file_unit $end
$var wire 1 X clk $end
$var wire 16 :" data_in_0 [15:0] $end
$var wire 16 ;" data_in_1 [15:0] $end
$var wire 3 <" read_addr_0 [2:0] $end
$var wire 3 =" read_addr_1 [2:0] $end
$var wire 3 >" reg_write_addr_0 [2:0] $end
$var wire 3 ?" reg_write_addr_1 [2:0] $end
$var wire 1 Y rst $end
$var wire 2 @" write_en_0 [1:0] $end
$var wire 2 A" write_en_1 [1:0] $end
$var wire 16 B" read_data_1 [15:0] $end
$var wire 16 C" read_data_0 [15:0] $end
$upscope $end
$scope task alu_test_inc $end
$upscope $end
$scope task load_store_test $end
$upscope $end
$scope task load_test_1 $end
$upscope $end
$scope task load_test_2 $end
$upscope $end
$scope task mov_test_1 $end
$upscope $end
$scope task reset $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
bx C"
bx B"
bx A"
bx @"
b1 ?"
bx >"
bx ="
bx <"
bx ;"
bx :"
bx 9"
x8"
x7"
bx 6"
bx 5"
bx 4"
bx 3"
bx 2"
bx 1"
bx 0"
bx /"
bx ."
bx -"
bx ,"
bx +"
bx *"
bx )"
bx ("
bx '"
bx &"
bx %"
bx $"
bx #"
bx ""
bx !"
bx ~
bx }
bx |
bx {
bx z
bx y
bx x
bx w
bx v
bx u
bx t
bx s
bx r
bx q
bx p
bx o
bx n
bx m
bx l
bx k
bx j
bx i
bx h
bx g
bx f
bx e
bx d
bx c
bx b
bx a
bx `
bx _
bx ^
bx ]
bx \
bx [
bx Z
0Y
0X
xW
bx V
bx U
bx T
bx S
bx R
bx Q
xP
xO
bx N
bx M
xL
bx K
xJ
xI
bx H
bx G
bx F
bx E
bx D
xC
bx B
xA
x@
bx ?
x>
x=
x<
x;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
bx 4
bx 3
bx 2
bx 1
bx 0
bx /
bx .
bx -
x,
x+
x*
bx )
bx (
bx '
x&
x%
bx $
bx #
bx "
bx !
$end
#5000000000000
b0 g
0J
0I
07"
b0 A"
b0 d
b0 T
b0 b
b0 z
b0 _
b0 U
b0 [
b0 6"
1W
b11 $
b11 f
b11 n
0C
0L
0>
0<
0A
1,
0P
b0 @"
b0 )
b0 :"
b0 V
b0 Z
b0 G
b0 5"
b0 H
b0 4"
0&
18"
0%
b10100000 :
b10100000 a
b10100000 ,"
b0 N
b0 j
b0 F
b0 k
b0 '
b0 3"
b0 ="
b0 (
b0 2"
b0 <"
b0 3
b0 m
b0 9
b0 e
b0 l
b0 ."
b0 "
b0 '"
0=
0*
b0 B
b0 $"
b0 Q
b0 #"
b0 ;"
b0 S
b0 ""
b0 1
b0 &"
b0 1"
b0 >"
b0 7
b0 %"
b0 K
b0 ]
b0 -"
b0 #
b0 y
b0 !"
0;
0@
0+
0O
b0 5
b0 u
b0 M
b0 ^
b0 r
b0 E
b0 s
b0 -
b0 i
b0 w
b0 /
b0 v
b0 2
b0 x
b0 ~
b0 0"
b0 8
b0 \
b0 t
b0 }
b0 /"
b0 6
b0 q
b0 +"
b0 D
b0 *"
b1011100011111111 !
b1011100011111111 ("
b0 4
b0 )"
b0 9"
b0 0
b0 p
b0 C"
b0 .
b0 o
b0 B"
1Y
1X
#10000000000000
0X
#15000000000000
0Y
1X
#20000000000000
0X
#25000000000000
b11111111 6"
1P
0W
b10 $
b10 f
b10 n
1,
b1111 N
b1111 j
b11111111 F
b11111111 k
b111 '
b111 3"
b111 ="
b111 (
b111 2"
b111 <"
b10111 9
b10111 e
b10111 l
b10111 ."
bx B
bx $"
bx Q
bx #"
bx ;"
b10100000 K
b10100000 ]
b10100000 -"
b11 #
b11 y
b11 !"
1+
b1011100011111111 D
b1011100011111111 *"
b1011000000010000 !
b1011000000010000 ("
b1 4
b1 )"
b1 9"
1X
#30000000000000
0X
#35000000000000
b10000 6"
b1 $
b1 f
b1 n
1,
1P
b11111111 U
b11111111 [
b1000 N
b1000 j
b10000 F
b10000 k
b100 '
b100 3"
b100 ="
b0 (
b0 2"
b0 <"
b10110 9
b10110 e
b10110 l
b10110 ."
b11 @"
b1000001000xxxxx !
b1000001000xxxxx ("
b10 4
b10 )"
b10 9"
b1 6
b1 q
b1 +"
b1011000000010000 D
b1011000000010000 *"
b10 #
b10 y
b10 !"
1O
b1111 M
b1111 ^
b1111 r
b11111111 E
b11111111 s
b10111 8
b10111 \
b10111 t
b10111 }
b10111 /"
b11 "
b11 '"
1*
1X
#40000000000000
0X
#45000000000000
b10000 U
b10000 [
b0xxxxx 6"
bx .
bx o
bx B"
1W
b11 $
b11 f
b11 n
1,
0P
b10 @"
bx N
bx j
b0xxxxx F
b0xxxxx k
bx '
bx 3"
bx ="
b1 3
b1 m
b1000 9
b1000 e
b1000 l
b1000 ."
b10 "
b10 '"
b10111 7
b10111 %"
b1 #
b1 y
b1 !"
b1 5
b1 u
b1000 M
b1000 ^
b1000 r
b10000 E
b10000 s
b10110 8
b10110 \
b10110 t
b10110 }
b10110 /"
b10 6
b10 q
b10 +"
b1000001000xxxxx D
b1000001000xxxxx *"
b1000010001xxxxx !
b1000010001xxxxx ("
b11 4
b11 )"
b11 9"
1X
#50000000000000
0X
#55000000000000
